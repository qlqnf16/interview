# Web

## 브라우저

브라우저의 핵심 기능: 사용자에게 필요한 자원을 서버에 요청하고, 응답을 받아 표시하는 것



### 브라우저의 구성 요소

![img](https://i.imgur.com/95xfCs0.png)



* 사용자 인터페이스: 컨텐츠가 표시되는 화면을 제외한 모든 부분 (주소입력창, 작업표시줄 등)
* 브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이를 제어
* **렌더링 엔진:** 응답받은 컨텐츠를 파싱해 화면에 표시
  1. HTML → DOM, CSS → CSSOM 으로 파싱
  2. DOM, CSSOM을 렌더트리로 결합
  3. 각 노드가 화면에 표시될 정확한 크기, 위치를 계산해 렌더 트리 배치
  4. 렌더트리를 기반으로 화면에 페인트
* 통신: HTTP 요청과 같은 네트워크 호출
* 자바스크립트 해석기
  HTML 파싱 중에 `<script>` 태그를 만나면 파싱을 중단, 자바스크립트 해석기가 실행된다.



## CORS (Cross-Origin Resource Sharing)

브라우저는 보안을 기본적으로 서로 다른 도메인간의 HTTP 요청을 제한한다. 이 때문에 발생하는 오류가 CORS. 서로 다른 도메인은 다음과 같은 경우를 말한다.

* http://domain1.com → http://domain2.com
* http://localhost:3000 → http://localhost:8080
* http://domain.com → https://domain.com



**해결방법**

* CORS 에러는 서버단에서 해결하는 것이 일반적이다.
  Access-Control-Allow-Origin header에서 도메인을 허용할 수 있다.
* 또는 프론트엔드 프록시 서버를 만들어 해결할 수 있다.



브라우저가 다른 도메인 요청을 할 때는 본요청 전에 `OPTIONS: preflight` 를 통해 사전요청을 보낸다. 이 요청을 통해 도메인이 허용된 도메인인지 감지한다. preflight 은 캐시를 이용해 저장될 수 있다.



## HTTP (Hypertext Transfer Protocol)

인터넷상에서 데이터를 주고받기 위한 통신 규약. 서버/클라이언트 모델 프로토콜로, 클라이언트가 요청하면 서버가 응답을 보내주는 방식을 사용한다. TCP/IP 프로토콜 위에서 작동한다.

**HTTP는 stateless, connectionless 라는 특성을 가진다.**

* 서버와 클라이언트간의 한 번의 요청이 끝나면 그대로 연결을 종료한다 (connectionless)
* 연결이 끊기는 순간 서버와 클라이언트의 통신이 끝나고, 상태정보는 저장되지 않는다 (stateless)
  여기에서 발생하는 문제를 해결하기 위해 **쿠키와 세션**을 사용한다



### HTTP Message 

<img width="966" alt="Screen Shot 2021-05-29 at 2 49 41 AM" src="https://user-images.githubusercontent.com/37537216/120023276-87881780-c028-11eb-9e79-607e41e01064.png">

* method: GET, POST, PATCH 등 http verb
* path: 요청하는 자원의 위치를 명시한 URI
* status code / status message: 요청의 성공 여부와 간단한 메세지 
  (2XX-성공, 3XX-redirection, 4XX-클라이언트 에러, 5XX-서버 에러)



## 쿠키와 세션

기본적으로 HTTP 통신은 stateless 하기 때문에 데이터를 저장하지 않는다. 

이를 보완하기 위해 사용하는 것이 쿠키와 세션.



### 쿠키

클라이언트에 key-value 형태로 저장되는 데이터. 서버에서 response header에 쿠키를 담아 보내면 클라이언트가 저장한다. 다음 요청부터 클라이언트가 가진 쿠키가 request header에 담겨 전송된다.

* 도메인당 최대 20개, 쿠키당 최대 4KB라는 용량 제한을 가진다.
* 만료기간을 설정할 수 있어 만료기간이 지나면 쿠키가 삭제된다.
* 클라이언트에 저장되므로 보안에 취약하다.
* 쇼핑몰 장바구니, 자동완성 저장, 일주일동안 보이지 않기 등에 사용된다.



### 세션

보안에 취약하고 저장용량이 제한적인 쿠키의 단점을 보완한 것. 클라이언트가 아닌 서버에 저장된다. 서버는 브라우저마다 고유한 세션키를 부여하고, 세션키를 쿠키에 담아 보낸다. 클라이언트는 세션키를 쿠키에 저장하고, 요청시마다 세션키를 이용해 세션의 정보를 가져올 수 있다.

* 서버에 저장되므로 쿠키에 비해 상대적으로 강한 보안

  → 여러 브라우저에서 요청이 들어오면 서버 저장공간에 부하가 생길 수 있다.

* 로그인 정보 등 강한 보안을 필요로 하는 정보를 저장하는 데 사용한다.



### Web Storage

쿠키의 단점을 보완하기 위해 HTML5부터 도입된 기능. 쿠키/세션과 달리 오직 브라우저가 저장하고 관리한다. 쿠키보다 큰 용량을 가진다.

* **localStorage**: 브라우저가 반영구적으로 저장하는 정보. 탭을 닫고 다시 열더라도 유지된다
* **sessionStorage**: 세션이 종료되기 전까지만 저장된다. 여러 개의 탭은 각각의 세션을 가진다.



## REST (Reprasantational State Transfer)

자원을 이름으로 구분해 자원의 상태 정보를 주고받는 것. HTTP URI를 이용해 자원을 명시하고 HTTP Method를 이용해 해당 자원의 CRUD Operation을 정의하는 것

| HTTP Method | Route      | CRUD                    |
| ----------- | ---------- | ----------------------- |
| `GET`       | /users     | 모든 유저 정보 가져오기 |
| `GET`       | /users/:id | 특정 유저 정보 가져오기 |
| `POST`      | /users     | 새로운 유저 생성        |
| `PATCH`     | /users/:id | 특정 유저 정보 수정     |
| `DELETE`    | /users/:id | 특정 유저 정보 삭제     |



### PATCH vs PUT

둘 다 특정한 자원의 정보를 수정한다는 공통점. `PATCH` 는 body에 명시된 부분을 수정하는 요청이고(자원의 부분 교체), `PUT`은 body에 명시된 부분으로 수정하는 요청이다(자원의 전체 교체).



* `{ "name": "jeongmin", "age": 27 }`이라는 객체가 있다고 했을 때
* `PATCH /users/1 { "age": 28 }` 요청을 보내면, 
  객체는 `{ "name": "jeongmin", "age": 28 }` 로 수정된다.
* `PUT /users/1 { "age": 28 }` 요청을 보내면, 
  객체는 `{ "name": null, "age": 28 }` 로 수정된다.

